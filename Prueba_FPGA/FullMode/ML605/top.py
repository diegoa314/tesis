import os
import sys
import random
from migen import *
from migen.fhdl import verilog
from tx import TX
from top_rx import RX
from prbs import PRBS7Generator
from migen.genlib.fifo import AsyncFIFO
class top_tx(Module):
    def __init__(self):
        self.we=Signal() #Un pulso para generar n datos del prbs
        self.link_ready=Signal() 
        self.reset=Signal()
        self.tx_data_out=Signal(40) #Salida de tx para GTX
        self.tx_init_done=Signal() 
        self.write_clk=Signal() 
        self.tx_clk=Signal() 

        #RX
        self.rx_data_in=Signal(40) #Recibido por GTX Rx
        self.rx_init_done = rx_init_done = Signal()
        self.trans_en = trans_en = Signal() #habilitador para el envio
        self.tx_serial= tx_serial = Signal() #senhal serial de salida
        self.rx_clk=Signal()
        #	#	#
        tx=TX()
        tx=ClockDomainsRenamer("tx")(tx)
        rx=RX()
        rx=ClockDomainsRenamer("rx")(rx)
        fifo=AsyncFIFO(width=34,depth=32)
        fifo=ClockDomainsRenamer({"read":"tx"})(fifo)
        prbs=PRBS7Generator(n_out=32)
        prbs=ClockDomainsRenamer("write")(prbs)
        self.submodules+=[fifo,tx,rx,prbs]
        prbs_en=Signal()
        n_data=5 #number of data generated by the PRBS
        data_type=Signal(2)
        index=Signal(max=n_data+2)
        i_ignored=Signal(max=n_data-1)
        write_fifo=Signal()
        self.comb+=i_ignored.eq(random.randint(2,n_data-1))
        self.submodules.prbs_fsm=FSM(reset_state="INIT")
        self.prbs_fsm=ClockDomainsRenamer("write")(self.prbs_fsm)
        self.prbs_fsm.act("INIT",
            If(self.we,
                NextValue(prbs_en,1),
                NextValue(data_type,1),
                NextValue(write_fifo,1),
                NextState("SOP")
            )
        )
        self.prbs_fsm.act("SOP",
            NextValue(data_type,0),
            NextValue(index,index+1),
            NextState("MIDDLE_WORD")
        )    
        
        self.prbs_fsm.act("MIDDLE_WORD",
            If(index<n_data,
                If(index==i_ignored-1,
                    #NextValue(data_type,0b11)
                    NextValue(data_type,0b00)
                ).Else(
                    NextValue(data_type,0b00)
                ),
                NextValue(index,index+1),
                NextState("MIDDLE_WORD")
            ).Else(
                NextState("EOP"),
                NextValue(data_type,0b10),
                NextValue(index,0)
            )
        )
        self.prbs_fsm.act("EOP",
            NextValue(prbs_en,0),
            NextValue(write_fifo,0),
            NextState("WAITS_RESET")
        )
        self.prbs_fsm.act("WAITS_RESET",
            If(~self.we,
                NextState("INIT")

            )
        )
        self.comb+=[
            fifo.din.eq(Cat(prbs.o,data_type)),
            prbs.enable.eq(prbs_en),
            fifo.we.eq(write_fifo),
            fifo.re.eq(tx.fifo_re),
            tx.link_ready.eq(self.link_ready),
            tx.fifo_empty.eq(~fifo.readable),
            tx.tx_init_done.eq(self.tx_init_done),
            If((self.link_ready & fifo.readable), 
                tx.data_type_in.eq(fifo.dout[32:]),
                tx.data_in.eq(fifo.dout[:32]), 
            ),
            self.tx_data_out.eq(tx.data_out),
            # RX
            rx.rx_data_in.eq(self.rx_data_in),
            rx.rx_init_done.eq(self.rx_init_done),
            rx.trans_en.eq(self.trans_en),
            rx.tx_serial.eq(self.tx_serial),
        ]

        # tx clocking
        self.clock_domains.cd_tx = ClockDomain()
        self.comb+=[
            self.cd_tx.rst.eq(self.reset),
            self.cd_tx.clk.eq(self.tx_clk)
        ]        

        # rx clocking
        self.clock_domains.cd_rx = ClockDomain()
        self.comb+=[
            self.cd_rx.rst.eq(self.reset),
            self.cd_rx.clk.eq(self.rx_clk)
        ]
        
        # write clocking
        self.clock_domains.cd_write=ClockDomain() #fifo writing clock domain
        self.comb += [
            self.cd_write.clk.eq(self.write_clk),
            self.cd_write.rst.eq(self.reset)
        ]    

dut = top_tx()
verilog.convert(dut, {dut.link_ready,dut.reset, 
    dut.tx_data_out,dut.tx_init_done, dut.write_clk, dut.tx_clk,
    dut.rx_data_in, dut.rx_init_done, dut.trans_en, dut.tx_serial,
    dut.rx_clk}).write("top.v")
